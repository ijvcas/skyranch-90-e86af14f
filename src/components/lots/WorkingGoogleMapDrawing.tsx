
import React, { useEffect, useState, useRef } from 'react';
import { type Lot } from '@/stores/lotStore';
import { useSimplePolygonDrawing } from '@/hooks/useSimplePolygonDrawing';
import SimplifiedPolygonControls from './controls/SimplifiedPolygonControls';
import MapLotLabelsControl from './controls/MapLotLabelsControl';
import { toast } from 'sonner';

interface WorkingGoogleMapDrawingProps {
  lots: Lot[];
  onLotSelect: (lotId: string) => void;
}

const SKYRANCH_CENTER = { lat: 40.31764444, lng: -4.47409722 };
const SKYRANCH_NAME = "SkyRanch";

const WorkingGoogleMapDrawing = ({ lots, onLotSelect }: WorkingGoogleMapDrawingProps) => {
  const {
    mapRef,
    mapInstance,
    isMapReady,
    polygons,
    selectedLotId,
    isDrawing,
    startDrawing,
    stopDrawing,
    deletePolygon,
    getLotColor
  } = useSimplePolygonDrawing({ lots, onLotSelect });
  
  const [showLabels, setShowLabels] = useState(true);
  const [showPropertyName, setShowPropertyName] = useState(true);
  const [isMobile, setIsMobile] = useState(false);
  const labelsRef = useRef<{[key: string]: google.maps.Marker}>({});
  const propertyLabelRef = useRef<google.maps.Marker | null>(null);

  // Debug lots when component loads
  useEffect(() => {
    console.log('üîç WorkingGoogleMapDrawing: Total lots received:', lots.length);
    const autoGeneratedLots = lots.filter(lot => (lot as any).autoGenerated === true);
    const userCreatedLots = lots.filter(lot => (lot as any).autoGenerated !== true);
    console.log('üè¢ Auto-generated (property) lots:', autoGeneratedLots.length, autoGeneratedLots.map(l => l.name));
    console.log('üåø User-created (pasture) lots:', userCreatedLots.length, userCreatedLots.map(l => l.name));
  }, [lots]);

  // Detect mobile devices
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  // Extract lot number from lot name
  const getLotNumber = (lotName: string): string => {
    // Try to extract number from lot name (e.g., "Lote 1" -> "1", "Parcela 2A" -> "2A")
    const match = lotName.match(/(\d+[A-Za-z]?)/);
    return match ? match[1] : lotName.charAt(0).toUpperCase();
  };

  // Create or update lot labels on the map - now includes dependency on lot names
  useEffect(() => {
    if (!isMapReady || !mapInstance) return;

    // Clear existing labels if toggled off
    if (!showLabels) {
      Object.values(labelsRef.current).forEach(label => {
        label.setMap(null);
      });
      labelsRef.current = {};
      return;
    }

    // Create or update lot labels
    lots.forEach(lot => {
      // Skip if no polygon - check if polygon exists for this lot
      const lotPolygon = polygons.get(lot.id);
      if (!lotPolygon) {
        console.log(`‚ö†Ô∏è No polygon found for lot: ${lot.name}, skipping label creation`);
        return;
      }
      
      // Additional safety check - ensure polygon has a valid path
      const path = lotPolygon.getPath();
      if (!path || typeof path.getLength !== 'function') {
        console.log(`‚ö†Ô∏è Invalid polygon path for lot: ${lot.name}, skipping label creation`);
        return;
      }

      const pathLength = path.getLength();
      if (pathLength === 0) {
        console.log(`‚ö†Ô∏è Empty polygon path for lot: ${lot.name}, skipping label creation`);
        return;
      }
      
      // Calculate centroid of polygon
      let lat = 0, lng = 0;
      
      for (let i = 0; i < pathLength; i++) {
        const point = path.getAt(i);
        if (point && typeof point.lat === 'function' && typeof point.lng === 'function') {
          lat += point.lat();
          lng += point.lng();
        }
      }
      
      lat /= pathLength;
      lng /= pathLength;
      
      // Create or update label with just the lot number
      if (labelsRef.current[lot.id]) {
        labelsRef.current[lot.id].setPosition({ lat, lng });
        labelsRef.current[lot.id].setLabel({
          text: getLotNumber(lot.name),
          color: '#ffffff',
          fontSize: '12px',
          fontWeight: '700'
        });
      } else {
        const label = new google.maps.Marker({
          position: { lat, lng },
          map: mapInstance,
          label: {
            text: getLotNumber(lot.name),
            color: '#ffffff',
            fontSize: '12px',
            fontWeight: '700'
          },
          icon: {
            path: 'M 0,0 C 0,0 0,0 0,0 Z', // Empty path - just the label
            scale: 1,
          },
          clickable: true
        });
        
        label.addListener('click', () => {
          onLotSelect(lot.id);
        });
        
        labelsRef.current[lot.id] = label;
      }
    });
    
    // Remove labels for deleted polygons
    Object.keys(labelsRef.current).forEach(lotId => {
      if (!polygons.has(lotId)) {
        labelsRef.current[lotId].setMap(null);
        delete labelsRef.current[lotId];
      }
    });
    
  }, [isMapReady, mapInstance, lots, polygons, showLabels, onLotSelect]);
  
  // Create or update property name label
  useEffect(() => {
    if (!isMapReady || !mapInstance) return;
    
    if (!showPropertyName) {
      if (propertyLabelRef.current) {
        propertyLabelRef.current.setMap(null);
        propertyLabelRef.current = null;
      }
      return;
    }
    
    if (!propertyLabelRef.current) {
      propertyLabelRef.current = new google.maps.Marker({
        position: SKYRANCH_CENTER,
        map: mapInstance,
        label: {
          text: SKYRANCH_NAME,
          color: '#ffffff',
          fontSize: '16px',
          fontWeight: 'bold'
        },
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 0, // Makes the icon invisible
        }
      });
    } else {
      propertyLabelRef.current.setMap(mapInstance);
    }
    
  }, [isMapReady, mapInstance, showPropertyName]);
  
  // Cleanup labels on unmount
  useEffect(() => {
    return () => {
      Object.values(labelsRef.current).forEach(label => {
        label.setMap(null);
      });
      
      if (propertyLabelRef.current) {
        propertyLabelRef.current.setMap(null);
      }
    };
  }, []);

  // Handle polygon deletions - show toast message
  const handleDeletePolygon = async (lotId: string) => {
    try {
      await deletePolygon(lotId);
      toast.success('Pol√≠gono eliminado correctamente');
    } catch (error) {
      console.error('Error deleting polygon:', error);
      toast.error('Error al eliminar el pol√≠gono');
    }
  };

  // Clear only user-created (pasture) polygons, not property lots
  const handleClearPastureLots = () => {
    console.log('üßπ Clearing pasture lots...');
    const pastureLots = lots.filter(lot => (lot as any).autoGenerated !== true);
    console.log('üåø Pasture lots to clear:', pastureLots.length);
    pastureLots.forEach(lot => {
      const polygon = polygons.get(lot.id);
      if (polygon) {
        console.log('üóëÔ∏è Removing polygon for pasture lot:', lot.name);
        polygon.setMap(null);
      }
    });
  };

  // Handle starting drawing for a specific lot
  const handleStartDrawing = (lotId: string) => {
    console.log('üéØ Starting drawing for lot:', lotId);
    startDrawing(lotId);
  };

  // Calculate polygon count from Map
  const polygonCount = polygons.size;

  // Debug polygon rendering
  useEffect(() => {
    if (isMapReady && polygons.size > 0) {
      console.log('üó∫Ô∏è Current polygons on map:', polygons.size);
      polygons.forEach((polygon, lotId) => {
        const lot = lots.find(l => l.id === lotId);
        if (lot) {
          console.log(`üìç Polygon for lot ${lot.name} (${(lot as any).autoGenerated ? 'auto-generated' : 'user-created'}): visible=${polygon.getVisible()}`);
        }
      });
    }
  }, [isMapReady, polygons, lots]);

  return (
    <div className="relative w-full h-[48rem] rounded-lg overflow-hidden bg-gray-100">
      {/* Loading overlay */}
      {!isMapReady && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-100 z-10">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto mb-4"></div>
            <p className="text-gray-600 font-medium">Inicializando Google Maps...</p>
            <p className="text-sm text-gray-500">Cargando herramientas de dibujo y geometr√≠a</p>
          </div>
        </div>
      )}
      
      {/* Map container with mobile optimizations */}
      <div 
        ref={mapRef} 
        className="w-full h-full" 
        style={{ touchAction: isMobile ? 'manipulation' : 'auto' }}
      />
      
      {/* Mobile notice */}
      {isMapReady && isMobile && (
        <div className="absolute top-2 left-2 right-2 bg-white p-2 rounded-md shadow-md z-10 text-sm text-center">
          <p className="font-medium text-gray-700">
            Usa dos dedos para mover el mapa y pellizcar para zoom
          </p>
        </div>
      )}
      
      {/* Controls overlay - thin lot count banner at top-center */}
      {isMapReady && (
        <>
          <div className="absolute top-4 left-1/2 transform -translate-x-1/2 z-10">
            <SimplifiedPolygonControls
              onClearAll={handleClearPastureLots}
              selectedLotId={selectedLotId}
              onDeleteSelected={() => {
                if (selectedLotId) {
                  handleDeletePolygon(selectedLotId);
                }
              }}
              polygonCount={polygonCount}
              lots={lots}
              onStartDrawing={handleStartDrawing}
              isDrawing={isDrawing}
            />
          </div>
          
          <MapLotLabelsControl
            showLabels={showLabels}
            onToggleLabels={setShowLabels}
            showPropertyName={showPropertyName}
            onTogglePropertyName={setShowPropertyName}
          />
        </>
      )}
    </div>
  );
};

export default WorkingGoogleMapDrawing;
