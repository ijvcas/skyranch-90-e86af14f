
import { EmailRequest, EmailResult, EmailTransport, EventDetails } from '../interfaces/EmailTypes';
import { EmailValidator } from './EmailValidator';
import { EmailErrorHandler } from './EmailErrorHandler';
import { emailLogger } from './EmailLogger';
import { GmailTransport } from '../transport/GmailTransport';
import { CalendarEventTemplate } from '../templates/CalendarEventTemplate';
import { TestEmailTemplate } from '../templates/TestEmailTemplate';

export class EmailEngine {
  private transport: EmailTransport;
  private calendarTemplate: CalendarEventTemplate;
  private testTemplate: TestEmailTemplate;

  constructor() {
    this.transport = new GmailTransport();
    this.calendarTemplate = new CalendarEventTemplate();
    this.testTemplate = new TestEmailTemplate();
    
    emailLogger.info('üìß [EMAIL ENGINE] Initialized with Gmail transport');
  }

  async sendCalendarEventEmail(
    to: string,
    eventType: 'created' | 'updated' | 'deleted' | 'reminder',
    eventDetails: EventDetails,
    userName?: string
  ): Promise<EmailResult> {
    emailLogger.info('üìÖ [EMAIL ENGINE] Sending calendar event email via Gmail', { 
      to, 
      eventType, 
      eventTitle: eventDetails.title 
    });

    try {
      // Generate email content using template
      const emailContent = this.calendarTemplate.render({
        userName: userName || to.split('@')[0],
        organizationName: 'SkyRanch',
        title: eventDetails.title,
        content: '', // Content is generated by template
        eventType,
        event: eventDetails
      });

      // Prepare email request
      const emailRequest: EmailRequest = {
        to: { email: to },
        content: emailContent,
        metadata: {
          senderName: "SkyRanch - Sistema de Gesti√≥n Ganadera",
          organizationName: "SkyRanch",
          tags: [
            { name: 'category', value: 'calendar-event' },
            { name: 'event-type', value: eventType },
            { name: 'sender', value: 'skyranch' },
            { name: 'transport', value: 'gmail' }
          ]
        },
        eventDetails
      };

      // Validate request
      const validation = EmailValidator.validateEmailRequest(emailRequest);
      if (!validation.valid) {
        const error = EmailErrorHandler.handleValidationError(validation.errors);
        return {
          success: false,
          error: error.message,
          details: error
        };
      }

      // Send email via Gmail
      return await this.transport.send(emailRequest);

    } catch (error) {
      emailLogger.error('‚ùå [EMAIL ENGINE] Calendar event email failed', error);
      const emailError = EmailErrorHandler.categorizeError(error);
      
      return {
        success: false,
        error: emailError.message,
        details: emailError
      };
    }
  }

  async sendTestEmail(to: string, testType: 'basic' | 'integration' | 'stress' = 'basic'): Promise<EmailResult> {
    emailLogger.info('üß™ [EMAIL ENGINE] Sending test email via Gmail', { to, testType });

    try {
      // Generate email content using template
      const emailContent = this.testTemplate.render({
        userName: to.split('@')[0],
        organizationName: 'SkyRanch',
        title: 'Test Email - Gmail Integration',
        content: '', // Content is generated by template
        testType
      });

      // Prepare email request
      const emailRequest: EmailRequest = {
        to: { email: to },
        content: emailContent,
        metadata: {
          senderName: "SkyRanch - Sistema de Gesti√≥n Ganadera",
          organizationName: "SkyRanch",
          tags: [
            { name: 'category', value: 'test' },
            { name: 'test-type', value: testType },
            { name: 'sender', value: 'skyranch' },
            { name: 'transport', value: 'gmail' }
          ]
        }
      };

      // Validate request
      const validation = EmailValidator.validateEmailRequest(emailRequest);
      if (!validation.valid) {
        const error = EmailErrorHandler.handleValidationError(validation.errors);
        return {
          success: false,
          error: error.message,
          details: error
        };
      }

      // Send email via Gmail
      return await this.transport.send(emailRequest);

    } catch (error) {
      emailLogger.error('‚ùå [EMAIL ENGINE] Test email failed', error);
      const emailError = EmailErrorHandler.categorizeError(error);
      
      return {
        success: false,
        error: emailError.message,
        details: emailError
      };
    }
  }

  async sendCustomEmail(request: EmailRequest): Promise<EmailResult> {
    emailLogger.info('üîß [EMAIL ENGINE] Sending custom email via Gmail', { 
      to: Array.isArray(request.to) ? request.to.map(t => t.email) : request.to.email,
      subject: request.content.subject
    });

    try {
      // Add Gmail transport tag to metadata
      if (!request.metadata) {
        request.metadata = {};
      }
      if (!request.metadata.tags) {
        request.metadata.tags = [];
      }
      request.metadata.tags.push({ name: 'transport', value: 'gmail' });

      // Validate request
      const validation = EmailValidator.validateEmailRequest(request);
      if (!validation.valid) {
        const error = EmailErrorHandler.handleValidationError(validation.errors);
        return {
          success: false,
          error: error.message,
          details: error
        };
      }

      // Send email via Gmail
      return await this.transport.send(request);

    } catch (error) {
      emailLogger.error('‚ùå [EMAIL ENGINE] Custom email failed', error);
      const emailError = EmailErrorHandler.categorizeError(error);
      
      return {
        success: false,
        error: emailError.message,
        details: emailError
      };
    }
  }

  // Utility methods
  getLogger() {
    return emailLogger;
  }

  async healthCheck(): Promise<{ healthy: boolean; details: any }> {
    emailLogger.info('üè• [EMAIL ENGINE] Performing Gmail email system health check');
    
    try {
      // We could test connectivity, API keys, etc. here
      // For now, just check if transport is available
      const healthy = !!this.transport;
      
      return {
        healthy,
        details: {
          transportAvailable: !!this.transport,
          transportType: 'gmail',
          templatesLoaded: !!(this.calendarTemplate && this.testTemplate),
          timestamp: new Date().toISOString()
        }
      };
    } catch (error) {
      emailLogger.error('‚ùå [EMAIL ENGINE] Health check failed', error);
      return {
        healthy: false,
        details: { error: error.message }
      };
    }
  }
}

// Singleton instance
export const emailEngine = new EmailEngine();
