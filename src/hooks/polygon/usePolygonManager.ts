
import { useState, useCallback } from 'react';
import { saveLotPolygon, deleteLotPolygon, getLotPolygons } from '@/services/polygonService';
import { useLotStore } from '@/stores/lotStore';
import { toast } from 'sonner';

export const usePolygonManager = (
  map: google.maps.Map | null,
  onPolygonClick?: (lotId: string) => void
) => {
  const [polygons, setPolygons] = useState<Map<string, google.maps.Polygon>>(new Map());
  const { addLot } = useLotStore();

  const calculatePolygonArea = useCallback((polygon: google.maps.Polygon): number => {
    const area = google.maps.geometry.spherical.computeArea(polygon.getPath());
    return area / 10000; // Convert from mÂ² to hectares
  }, []);

  const handlePolygonComplete = useCallback(async (
    polygon: google.maps.Polygon, 
    lotName: string
  ) => {
    if (!map) return;

    try {
      console.log(`ðŸŽ¯ Creating user polygon for lot:`, lotName);
      
      const area = calculatePolygonArea(polygon);
      console.log(`ðŸ“ Calculated area: ${area.toFixed(2)} hectares`);

      // Create user-created lot (not auto-generated)
      const success = await addLot({
        name: lotName,
        description: 'Lote de pastoreo creado por el usuario',
        sizeHectares: area,
        status: 'active',
        grassCondition: 'good',
        // No lotType field - handled by autoGenerated flag
      });

      if (success) {
        // Set polygon style for user-created lots (colored and editable)
        polygon.setOptions({
          fillColor: '#10B981',
          fillOpacity: 0.3,
          strokeColor: '#059669',
          strokeWeight: 2,
          strokeOpacity: 0.9,
          editable: true,
          clickable: true
        });
        
        toast.success(`Lote de pastoreo "${lotName}" creado exitosamente`);
      } else {
        polygon.setMap(null);
        toast.error('Error al crear el lote');
      }
    } catch (error) {
      console.error('âŒ Error creating polygon:', error);
      polygon.setMap(null);
      toast.error('Error al crear el lote');
    }
  }, [map, addLot, calculatePolygonArea]);

  const loadSavedPolygons = useCallback(async (lots: any[], customOptions?: any) => {
    if (!map || !lots.length) {
      console.log('âš ï¸ Cannot load polygons: no map or no lots');
      return;
    }

    try {
      console.log('ðŸ”„ Loading saved polygons for lots...', lots.length);
      const polygonData = await getLotPolygons();
      console.log('ðŸ“Š Retrieved polygon data:', polygonData.length);
      
      // Clear existing polygons before loading new ones
      polygons.forEach(polygon => polygon.setMap(null));
      setPolygons(new Map());
      
      lots.forEach((lot) => {
        const data = polygonData.find(p => p.lot_id === lot.id);
        if (!data?.coordinates) {
          console.log(`âš ï¸ No polygon data found for lot: ${lot.name} (${lot.id})`);
          return;
        }

        try {
          const coordinates = typeof data.coordinates === 'string' 
            ? JSON.parse(data.coordinates) 
            : data.coordinates;

          if (!Array.isArray(coordinates) || coordinates.length === 0) {
            console.log(`âš ï¸ Invalid coordinates for lot: ${lot.name}`);
            return;
          }

          const path = coordinates.map((coord: any) => ({
            lat: parseFloat(coord.lat || coord.latitude || coord[0]),
            lng: parseFloat(coord.lng || coord.longitude || coord[1])
          }));

          // Determine styling based on autoGenerated flag
          const isAutoGenerated = (lot as any).autoGenerated === true;
          console.log(`ðŸŽ¨ Creating polygon for ${isAutoGenerated ? 'auto-generated' : 'user-created'} lot: ${lot.name}`);
          
          const polygonOptions = customOptions || (isAutoGenerated ? {
            // Auto-generated lots: Gray, non-editable (property lots)
            fillColor: '#E5E7EB',
            fillOpacity: 0.15,
            strokeColor: '#6B7280',
            strokeWeight: 2,
            strokeOpacity: 0.8,
            editable: false,
            clickable: true
          } : {
            // User-created lots: Colored, editable (pasture lots)
            fillColor: '#10B981',
            fillOpacity: 0.3,
            strokeColor: '#059669',
            strokeWeight: 2,
            strokeOpacity: 0.9,
            editable: true,
            clickable: true
          });

          const polygon = new google.maps.Polygon({
            paths: path,
            map: map,
            ...polygonOptions
          });

          // Add click listener
          if (onPolygonClick) {
            polygon.addListener('click', () => {
              console.log(`ðŸ–±ï¸ Polygon clicked for ${isAutoGenerated ? 'auto-generated' : 'user-created'} lot: ${lot.name}`);
              onPolygonClick(lot.id);
            });
          }

          setPolygons(prev => new Map(prev.set(lot.id, polygon)));
          console.log(`âœ… Loaded polygon for ${isAutoGenerated ? 'property' : 'pasture'} lot: ${lot.name}`);
        } catch (error) {
          console.error(`âŒ Error parsing coordinates for lot ${lot.name}:`, error);
        }
      });
      
      console.log(`ðŸŽ¯ Total polygons loaded: ${polygons.size}`);
    } catch (error) {
      console.error('âŒ Error loading saved polygons:', error);
    }
  }, [map, onPolygonClick, polygons]);

  const deletePolygon = useCallback(async (lotId: string) => {
    const polygon = polygons.get(lotId);
    if (polygon) {
      polygon.setMap(null);
      setPolygons(prev => {
        const newMap = new Map(prev);
        newMap.delete(lotId);
        return newMap;
      });

      try {
        await deleteLotPolygon(lotId);
        console.log(`ðŸ—‘ï¸ Deleted polygon for lot: ${lotId}`);
      } catch (error) {
        console.error('âŒ Error deleting polygon from database:', error);
      }
    }
  }, [polygons]);

  const clearAllPolygons = useCallback(() => {
    console.log('ðŸ§¹ Clearing all polygons from map...');
    polygons.forEach(polygon => polygon.setMap(null));
    setPolygons(new Map());
  }, [polygons]);

  const updatePolygonVisibility = useCallback((lotId: string, visible: boolean) => {
    const polygon = polygons.get(lotId);
    if (polygon) {
      polygon.setVisible(visible);
    }
  }, [polygons]);

  return {
    polygons,
    handlePolygonComplete,
    loadSavedPolygons,
    deletePolygon,
    clearAllPolygons,
    updatePolygonVisibility
  };
};
